# Harper Edge AI Personalization Schema
# GraphQL schema definitions for outdoor gear AI recommendations

type Tenant @table @export {
  id: ID @primaryKey
  name: String!
  baseUrl: String!
  apiKey: String!
  apiKeyHeader: String!
  responseFormat: String!
  recommendationLimit: Int!
  personalizationBoost: Float!
  maxDiscount: Float!
  pricingStrategy: String!
  categoryWeights: Any!  # JSON object with category weights
  endpoints: Any!  # JSON array of endpoint configurations
  segmentationRules: Any!  # JSON object with segmentation rules
  contentRules: Any!  # JSON object with content personalization rules
  rateLimits: Any!  # JSON object with rate limiting configuration
  headers: Any!  # JSON object with default headers
  active: Boolean!
  created_at: Date!
  updated_at: Date!
  
  # Relationships
  sessions: [Session] @relationship(to: tenantId)
  statistics: [Statistic] @relationship(to: tenantId)
  userProfiles: [UserProfile] @relationship(to: tenantId)
}

type Session @table @export {
  id: ID @primaryKey
  tenantId: ID! @indexed
  userId: String @indexed
  sessionStart: Date!
  sessionEnd: Date
  userAgent: String
  ipAddress: String
  deviceType: String
  referrer: String
  totalInferences: Int!
  totalCacheHits: Int!
  avgResponseTime: Float!
  created_at: Date!
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
  statistics: [Statistic] @relationship(to: sessionId)
  userFeedback: [UserFeedback] @relationship(to: sessionId)
}

type Statistic @table @export {
  id: ID @primaryKey
  sessionId: ID! @indexed
  tenantId: ID! @indexed
  timestamp: Date! @indexed
  modelVersion: String! @indexed
  modelAlpha: Float
  inferenceTime: Int!
  preprocessingTime: Int
  totalTime: Int!
  memoryUsage: Any  # JSON object with memory stats
  topPrediction: Any!  # JSON object with top prediction
  allPredictions: Any!  # JSON array with all predictions
  inputMetadata: Any  # JSON object with input metadata
  userFeedback: Any  # JSON object with user feedback
  pageUrl: String
  created_at: Date!
  
  # Relationships
  session: Session @relationship(from: sessionId)
  tenant: Tenant @relationship(from: tenantId)
  feedback: [UserFeedback] @relationship(to: statId)
}

type UserProfile @table @export {
  id: ID @primaryKey
  tenantId: ID! @indexed
  userId: String! @indexed
  preferences: Any!  # JSON object with user preferences
  outdoorActivities: Any!  # JSON array of outdoor activities
  experienceLevel: String @indexed
  gearPreferences: Any!  # JSON object with gear preferences
  seasonalPreferences: Any!  # JSON object with seasonal preferences
  priceRange: Any!  # JSON object with price preferences
  brandAffinities: Any!  # JSON array of preferred brands
  purchaseHistory: Any!  # JSON array of purchase history
  behaviorMetrics: Any!  # JSON object with behavior analytics
  segmentTags: Any!  # JSON array of user segments
  lastActivity: Date! @indexed
  created_at: Date!
  updated_at: Date!
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
  feedback: [UserFeedback] @relationship(to: userId, from: userId)
}

type UserFeedback @table @export {
  id: ID @primaryKey
  statId: ID! @indexed
  sessionId: ID! @indexed
  tenantId: ID! @indexed
  userId: String! @indexed
  isCorrect: Boolean!
  correctedLabel: String
  confidence: Float
  feedbackType: String!  # 'explicit', 'implicit', 'conversion'
  context: Any  # JSON object with feedback context
  timestamp: Date! @indexed
  created_at: Date!
  
  # Relationships
  statistic: Statistic @relationship(from: statId)
  session: Session @relationship(from: sessionId)
  tenant: Tenant @relationship(from: tenantId)
  user: UserProfile @relationship(from: userId, to: userId)
}

type RetrainingJob @table @export {
  id: ID @primaryKey
  tenantId: ID! @indexed
  jobType: String!  # 'scheduled', 'triggered', 'manual'
  modelType: String!  # 'collaborative', 'content-based', 'hybrid'
  status: String! @indexed  # 'pending', 'running', 'completed', 'failed'
  priority: String!  # 'low', 'medium', 'high', 'critical'
  triggeredAt: Date! @indexed
  startedAt: Date
  completedAt: Date
  duration: Int  # Duration in milliseconds
  dataRange: Any!  # JSON object with date range
  triggerMetrics: Any!  # JSON object with trigger metrics
  trainingMetrics: Any!  # JSON object with training results
  modelMetrics: Any!  # JSON object with new model performance
  errorMessage: String
  retryCount: Int
  maxRetries: Int
  nextRetryAt: Date
  configuration: Any!  # JSON object with training configuration
  created_at: Date!
  updated_at: Date!
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
}

type PerformanceMetric @table @export {
  id: ID @primaryKey
  tenantId: ID! @indexed
  metricType: String! @indexed  # 'response_time', 'throughput', 'error_rate', etc.
  metricName: String! @indexed
  value: Float!
  unit: String!  # 'ms', 'requests/sec', 'percentage', etc.
  tags: Any  # JSON object with metric tags
  dimensions: Any  # JSON object with metric dimensions
  threshold: Float  # Alert threshold for this metric
  alertLevel: String  # 'info', 'warning', 'critical'
  source: String!  # 'proxy', 'ai_engine', 'cache', etc.
  timestamp: Date! @indexed
  created_at: Date!
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
}

# Metrics table from the existing metrics schema
type Metric @table @export {
  id: ID @primaryKey
  type: String! @indexed  # 'request', 'response', 'error', etc.
  tenantId: ID! @indexed
  endpoint: String! @indexed
  method: String
  statusCode: Int @indexed
  responseTime: Int
  cacheHit: Boolean @indexed
  enhanced: Boolean @indexed
  userId: String @indexed
  requestId: String @indexed
  clientIp: String
  userAgent: String
  deviceType: String
  sessionId: String @indexed
  responseSize: Int
  enhancementType: String @indexed
  aiInferenceTime: Int
  errorType: String
  errorMessage: String
  stackTrace: String
  timestamp: Date! @indexed
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
}

type AIModelMetric @table @export {
  id: ID @primaryKey
  modelName: String! @indexed
  tenantId: ID! @indexed
  inferenceTime: Int!
  accuracyScore: Float
  predictionConfidence: Float
  enhancementType: String @indexed
  inputFeatures: Any  # JSON object with input features
  outputResults: Any  # JSON object with output results
  userFeedback: Any  # JSON object with user feedback
  success: Boolean! @indexed
  errorMessage: String
  modelVersion: String @indexed
  batchSize: Int
  memoryUsage: Int
  timestamp: Date! @indexed
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
}

type CacheMetadata @table @export {
  id: ID @primaryKey
  cacheKey: String! @indexed
  tenantId: ID! @indexed
  endpoint: String! @indexed
  ttl: Int!
  sizeBytes: Int!
  compressionUsed: Boolean
  compressionRatio: Float
  accessCount: Int
  hitRate: Float
  personalized: Boolean @indexed
  cacheLayer: String @indexed  # 'hot', 'warm', 'cold'
  invalidationReason: String
  lastAccessed: Date @indexed
  createdAt: Date! @indexed
  expiresAt: Date! @indexed
  invalidatedAt: Date
  
  # Relationships
  tenant: Tenant @relationship(from: tenantId)
}